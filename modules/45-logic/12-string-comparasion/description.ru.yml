---

# Переписать на человеческий

name: Сравнение строк
theory: |

  Посмотрите на код и попытайтесь ответить, чему равны значение выражения: `true` или `false`?

  ```java
  "a" == "a"; // ?
  "a".toUpperCase() == "a".toUpperCase(); // ?
  ```

  Правильный ответ: в первом случае `true`, во втором - `false`. Почему? Для ответа на этот вопрос, нужно немного погрузиться в то, как работают компьютеры.

  В наших программах мы оперируем данными, такими как числа, строки, булевы значения и т.п. Записываем их в переменные, умножаем, делим, конкатенируем, в общем, выполняем разнообразные операции, которые приводят к желаемому результату. Так видит программист. Внутри компьютера, все немного по-другому. Во время своей работы, программа получает доступ и манипулирует данными через их адреса в памяти.

  ```java
  // Под хранение переменной выделяется область памяти
  // Программа запоминает адрес этой области и работает с ней внутри себя
  var name = "CodeBasics";
  // Программа считала значение переменной по адресу, где хранится значение
  System.out.println(name);
  ```

  Память - большая область для хранения данных, которая очень похожа на склад. Любое значение, которое туда помещается, получает номер, по которому это значение можно извлечь и заменить. Этот номер и есть адрес.

  ## Сравнение по ссылке и по значению

  Из-за этих технических особенностей, на сравнение данных между собой можно смотреть двумя способами: *то же самое* или *такое же*. *То же самое* - тот же участок памяти, *такое же* - одинаковые значения независимо от того, куда указывают адреса. Пример из реальной жизни, два одинаковых стакана несмотря на свою одинаковость, все же разные стаканы.

  Языки программирования по разному работают с этими понятиями. В Java, как и во многих других, все данные делятся на два больших типа: примитивные и ссылочные. Примитивные всегда сравниваются по значению независимо от адресов, а ссылочные - по адресам. Примитивные:

  ```java
  // Сравнение идет по значению, а не адресам
  4 == 4; // true
  true == true; // true
  10.0 == 10.0; // true
  ```

  Из ссылочных мы пока знакомы только со строками, но они работают хитро, поэтому в качестве примера посмотрим на массивы. Не обращайте внимание на незнакомый синтаксис, главное что видно из этого кода, что две вроде бы одинаковые штуки не равны друг другу:

  ```java
  // Создание массивов
  int[] a = {1, 2}
  int[] b = {1, 2}

  // Значения одинаковые, но ссылки разные
  a == b; // false
  ```

  ## Особенности строк

  Строки относятся к ссылочным типам данных, но, с первого взгляда, ведут себя странно:

  ```java
  // Сравнение как у примитивных типов данных
  "hm" == "hm"; // true

  // Сравнение как у ссылочных типов данных
  "hexlet".toUpperCase() == "hexlet".toUpperCase(); // false
  ```

  Программы постоянно оперируют строками, поэтому эффективность работы с ними выходит на первое место. Если бы строка всегда вела себя как ссылочный тип, то на каждое значение в коде выделялась дополнительная память:

  ```java
  // Без оптимизаций, это выражение бы привело к двойному выделению памяти
  // По куску на каждый "hm"
  "hm" == "hm";
  ```

  Но этого не происходит. Каждый раз когда Java встречает явно создаваемую строку, она выполняет проверку, а есть ли уже в памяти такая строка. Если есть, то она переиспользуется, если нет, то создается.

  ```java
  // Выделяется память
  var name1 = "Java";
  // Такая строка уже есть, поэтому подставляется ссылка на уже созданную строку
  // В результате экономится память
  var name2 = "Java";

  // Сравнение по ссылке
  // Обе переменные указывают на один участок памяти
  name1 == name2; // true
  ```

  Но если строка возвращается из метода, то она помещается в свою область памяти со своим уникальным адресом:

  ```java
  // Выделяется новая память в любом случае
  var name1 = "java".toUpperCase(); // "JAVA"

  // Выделяется новая память в любом случае
  var name2 = "java".toUpperCase(); // "JAVA"

  name1 == name2; // false
  ```

  *Здесь может показаться, что ссылочные данные приносят сплошные проблемы. На самом деле они нужны. Это станет понятно тогда, когда мы столкнемся с изменяемостью в будущем.*

  В прикладном программировании, мы чаще хотим сравнивать строки по значению, чем по ссылке. Для этого в строки встроен метод `equals()`:

  ```java
  var name1 = "java".toUpperCase(); // "JAVA"
  var name2 = "java".toUpperCase(); // "JAVA"

  name1.equals(name2); // true
  ```

  Помимо `equals()`, в строки встроен метод `equalsIgnoreCase()`, который выполняет проверку по значению без учета регистра:

  ```java
  var name1 = "java".toUpperCase(); // "JAVA"
  var name2 = "java".toLowerCase(); // "java"

  name1.equalsIgnoreCase(name2); // true
  ```

  Несмотря на то, что сравнение строк в Java иногда ведет себя как будто сравниваются значения, никогда не делайте ставку на это. При изменении кода легко забыть поправить проверку и получить ошибку. Всегда используйте методы, когда нужно сравнивать по значению.

instructions: |

  Реализуйте метод `isPalindrome()`, который определяет, является ли слово палиндромом или нет. Палиндром это слово, которое читается одинаково в обоих направлениях.

  ```java
  App.isPalindrome("шалаш"); // true
  App.isPalindrome("ага"); // true
  App.isPalindrome("хекслет"); // false

  // Слова в метод могут быть переданы в любом регистре
  App.isPalindrome("Ага"); // true
  ```

  Для определения палиндрома, необходимо перевернуть строку и сравнить ее с исходной. Для этого воспользуйтесь методом `StringUtils.reverse()`

  ```java
  StringUtils.reverse("мама"); // "амам"
  ```

# tips: []
