---

name: Передача одного аргумента
theory: |

  Часто методы принимают на вход данные, как-то их используют и выдают результат обратно. В этом уроке мы познакомимся с определением методов, принимающих на вход один параметр. Посмотрите на определение ниже:

  ```java
  const showCurrentDay = (text) => {
    console.log(`Today is: ${text}`);
  };

  showCurrentDay('January 29');
  ```

  <pre class='hexlet-basics-output'>Today is: January 29</pre>

  Теперь понятно, зачем нужны были круглые скобки после имени функции: в них *можно* указать аргументы (или, что то же самое, параметры). Технически, параметры функции всегда являются переменными, а не константами. Но лучше относиться к ним как к константам.

  Заметьте: мы не определяем переменную `text`, но используем её в теле функции. JavaScript работает так: переменная сама создаётся при вызове, и указанное значение (в нашем примере — `'January 29'`) записывается в эту переменную.

  Аргументы можно называть как угодно, их имена имеют смысл исключительно в теле функции. Например, если изменить имя аргумента так:

  ```javascript
  const showCurrentDate = (lala) => {
    console.log(`Today is: ${lala}`);
  };

  const date = 'January 29';
  showCurrentDate(date);
  ```

  то поведение функции не изменится. Это касается как имен внутри функции (`lala`), так и снаружи (`date`).

  Новички иногда пытаются сделать примерно такое определение функции:

  ```javascript
  const showCurrentDate = ('Today is: December 5') => {
    // какой-нибудь код
  };
  ```

  Запустить такой код не получится — он содержит синтаксическую ошибку. Вместо переменной в аргументе написана строка, то есть значение.

  *Аргумент должен быть переменной*, иначе он не сможет быть аргументом, то есть чем-то, что *принимает значение при вызове*.

  Если же вам нужна какая-то информация в функции, и вы заранее знаете какая именно, то аргумент для этого не нужен, ведь мы уже умеем сохранять значения для последующего использования —  достаточно создать константу в самом теле:

  ```javascript
  const showCurrentDate = () => {
    const text = 'Today is: December 5';
    // какой-нибудь код
  };
  ```

instructions: |

  Сэм составляет множество карт, и ему часто нужно выводить на экран повторяющиеся символы для визуализации маршрутов. Например, так Сэм иллюстрирует узкие дороги между городами:

  <pre class='hexlet-basics-output'>
  Meereen =-=-=-=- Myr
  </pre>

  А так иллюстрирует широкие трассы:

  <pre class='hexlet-basics-output'>
  Vaes Dothrak ======== Vahar
  </pre>

  Сэм где-то нашёл метод `repeat()` из класса `Functions`. Он принимает два аргумента: какое-то число N и строку, и возвращает повторенную N раз строку. Вот как он использует его:

  ```java
  System.out.println(Functions.repeat("=-", 4));
  ```

  <pre class='hexlet-basics-output'>=-=-=-=-</pre>

  Сэм не очень доволен. Неудобно вызывать сотни раз `repeat()` внутри вызова `System.out.println()`.

  Напишите для Сэма метод `printSeq()`, который сам выводит на экран получившиеся повторения. Он принимает два аргумента — строку и число, и выводит повторяющуюся строку на экран. Для генерации строки используйте `repeat()`.

  Вот пример того, как Сэм будет использовать написанный вами метод `printSeq()`:

  ```java
  App.printSeq("=-", 4);
  ```

  <pre class='hexlet-basics-output'>=-=-=-=-</pre>

  Как обычно, метод нужно сделать `public static`, а не просто `static`, чтобы мы смогли вызвать его из другого класса.

tips:
  - |
    Чтобы указать в аргументах метода printSeq() целое число, используйте тип данных `int`.
